#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <poll.h>

//stdlib.h
extern void free(void*);
extern void *malloc(size_t);
extern int atoi(char*);
extern void exit(int);

//string.h
extern size_t strlen(char*);
extern void *memset(void*, int, size_t);

//unistd.h
extern int close(int);

struct byteArray{
	size_t size;
	char* arr;
};

void poolFree(void *ptr){
	free(ptr);
}
void *poolAlloc(size_t size){
	//TODO: use a pool of previously-allocated chunks
	//	Why? Isn't that malloc's job?
	return malloc(size);//for now
}

void freeRbarr(struct byteArray *arr){
	poolFree(arr);
}
struct byteArray *referenceBarr(size_t size, void* ptr){
	struct byteArray *result = (struct byteArray*) poolAlloc(sizeof(struct byteArray));
	result->size = size;
	result->arr = ptr;
	return result;
}
void freeBarr(struct byteArray *arr){
	poolFree(arr->arr);//TODO: check error value
	freeRbarr(arr);
}
struct byteArray *allocBarr(size_t size){
	return referenceBarr(size, poolAlloc(size));
}

struct byteArray *strToRbarr(char *str){
	return referenceBarr(strlen(str), str);
}
void printBarr(struct byteArray *barr){
	int i;
	for(i = 0; i < barr->size; i++)
		printf("%c", barr->arr[i]);
}
struct byteArray *argsToBarr(int arfc, char* *arfv){
	int i;
	struct byteArray* *rbarrs;
	struct byteArray *result = allocBarr(arfc * sizeof(struct byteArray*));
	rbarrs = (struct byteArray**)(result->arr);
	for(i = 0; i < arfc; i++)
		rbarrs[i] = strToRbarr(arfv[i]);
	return result;
}
void freeArgsBarr(struct byteArray *args){
	int i;
	for(i = 0; i < args->size / sizeof(struct byteArray*); i++)
		freeRbarr(((struct byteArray**)(args->arr))[i]);
	freeBarr(args);
}


void printAddrinfo(struct addrinfo *info){
	void *addr;
	char ipstr[INET6_ADDRSTRLEN];
	int j;
	if(AF_INET == info->ai_family){
		printf("IPv4 ");
		addr = &(((struct sockaddr_in*)info->ai_addr)->sin_addr);
	}
	else if(AF_INET6 == info->ai_family){
		printf("IPv6 ");
		addr = &(((struct sockaddr_in6*)info->ai_addr)->sin6_addr);
	}
	else{
		printf("%d ", info->ai_family);
		addr = 0;
	}
//	printf("%s %d ", info->ai_canonname, info->ai_addrlen);
	if(addr){
		inet_ntop(info->ai_family, addr, ipstr, sizeof ipstr);
		printf("%s", ipstr);
	}
	else
		for(j = 0; j < info->ai_addrlen; j++)
	//		printf("%02x", ((char*)(info->ai_addr))[j]);
			printf("%d,", ((char*)(info->ai_addr))[j]);
}

int barrMain(struct byteArray *args){
	int i, sock, len, status;
	struct byteArray* *rbarrs;
	struct addrinfo hints, *servinfo, *ptr;
	char *port;

	len = args->size / sizeof(struct byteArray*);
	port = "15211";
	rbarrs = (struct byteArray**)(args->arr);
	if(len > 1)
		port = rbarrs[1]->arr;
	printf("port %s\n", port);

	memset(&hints, 0, sizeof hints);
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_flags = AI_PASSIVE;
	status = getaddrinfo(NULL, port, &hints, &servinfo);
	if(status){
		printf("status %d\n", status);
		exit(status);
	}

	ptr = servinfo;
	i = 0;
	sock = -1;
	while(ptr && -1 == sock){
//		printf(" %d ", i);
//		printAddrinfo(ptr);
//		printf("\n");
		sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
		if(-1 == sock){
			ptr = ptr->ai_next;
			i++;
		}
	}
	printf("socket %d\n", sock);
	if(-1 == sock){
		freeaddrinfo(servinfo);
		printf("oops, no socket\n");
		exit(1);
	}
	status = bind(sock, ptr->ai_addr, ptr->ai_addrlen);
	if(-1 == status){
		freeaddrinfo(servinfo);
		printf("bind fail\n");
		close(sock);
		exit(1);
	}
	//status = listen(sock, 8);
	if(-1 == status){
		freeaddrinfo(servinfo);
		printf("listen fail\n");
		close(sock);
		exit(1);
	}
	//status = accept(sock, ptr->ai_addr, ptr->ai_addrlen);
	if(-1 == status){
		freeaddrinfo(servinfo);
		printf("accept fail\n");
		close(sock);
		exit(1);
	}
	int done = 1;
	while(!done){
		//poll(
		//status = accept(sock, ptr->ai_addr, ptr->ai_addrlen);
		
	}
	freeaddrinfo(servinfo);
	close(sock);

	for(i = 0; i < len; i++){
		printBarr(rbarrs[i]);
		if(i+1 < len)
			printf(" ");
	}
	printf("\n");
	return 0;
}

int main(int arfc, char* *arfv){
	int result;
	struct byteArray *args = argsToBarr(arfc, arfv);
	result = barrMain(args);
	freeArgsBarr(args);
	return result;
}
